### 第10章 CALL和REL指令
- call和ret指令都是转移指令,它们都修改IP,或同时修改CS和IP,它们经常被共同用来实现子程序的设计.这一章讲解call和
ret指令的原理.
- 10.1 ret和retf
```code
ret指令用栈中的数据,修改IP的内容,从而实现近转移.
retf指令用栈中的数据,修改CS和IP的内容,从而实现远转移.
CPU执行ret指令时,进行下面两步
1. (IP)=((SS)*16+SP)
2.(SP)=(SP)+2
CPU执行reft指令时,进行下面4步操作:
1.(IP)=((SS)*16+(SP))
2.(SP)=(SP)+2
3.(CS)=((SS)*16+(SP))
4.(SP)=(SP)+2
可以看出,如果我们用汇编语法来解释ret和retf指令,则:
CPU执行ret指令时,相当于
pop ip
CPU执行retf指令时,相当于
pop ip
pop cs
下面的程序,ret指令执行后,(IP)=0,CS:IP指向代码的第一条指令
assume cs:code
stack segment
    db 16 dup(0)
stack ends
code segment
    mov ax,4c00h
    int 21h
start: mov ax,stack
       mov ss,ax
       mov sp,16
       mov ax,0
       push ax
       mov bx,0
       ret
code ends
end start   

下面的程序,retf指令执行后,(IP)=0,CS:IP指向代码的第一条指令  
assume cs:code
stack segment
    db 16 dup(0)
stack ends     
start: mov ax,stack
       mov ss,ax
       mov sp,16
       mov ax,0
       push cs
       push ax
       mov bx,0
       retf
code ends
end start  
```
#### 10.2 call指令
- CPU执行call指令时,进行两步操作:
  1. 将当前的IP或CS和IP压入栈中
  2. 转移
- call指令不能实现短转移
#### 10.3 依据位移进行转移的call指令
```code
call标号(将当前的IP压栈后,转到标号处执行指令)
CPU执行此种格式的call指令时,进行如下操作
1. (sp)=(sp)-2
   ((ss)*16+(sp))=(ip)
2. (ip)=(ip)+16位位移
16位位移=标号处的地址-call指令后的第一个字节的地址;
16位位移的范围为-32768~32767,用补码表示
16位位移由编译程序在编译时算出

用汇编语法来解释此格式的call指令,则
push ip
jmp near ptr 标号   
```
#### 10.4 转移的目的地址在指令中的call指令
```code
前面讲的call指令,其对应的机器指令并没有转移到目标地址,而是相对于当前IP的转移位移
call far ptr 标号,实现的是段间转移
CPU执行此格式的call指令时,进行如下操作.
1. (sp)=(sp)-2
   ((ss)*16+(sp))=(ip)
   (sp)=(sp)-2 
   ((ss)*16+(sp))=(ip)
2. (cs)=标号所在的段地址
   (IP)=标号在段中的偏移地址
用汇编来解释此种格式的call指令
push cs
push ip
jmp far ptr 标号   
```
#### 10.5 转移地址在寄存器中的call指令
```code
指令格式: call 16位reg
功能:
(sp)=(sp)-2
((ss)*16+(sp))=(ip)
(ip)=(16位reg)
用汇编语法来解释此格式的call指令
push ip
jmp 16位reg
```
#### 10.6 转移地址在内存中的call指令
```code
转移地址在内存中的call指令有两种格式
1 call word ptr 内存单元地址
用汇编语法来解释此格式的call指令
push ip
jmp word ptr 内存单元地址
比如,下面的指令
mov sp,10h
mov ax,0123h
mov ds:[0],ax
call word ptr ds:[0]

比如 下面的指令
mov sp,10h
mov ax,0123h
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
```
#### 10.7 call和ret的配合使用
```code

```
### 11 标志寄存器
- CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理机,个数和结构都可能不同)
具有以下3种作用
#### 11.1 zf标志
