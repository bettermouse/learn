## 汇编语言王爽
### 前言
- 汇编语言是各种CPU所提供的机器指令的助记符号集合.可以用汇编语言直接控制硬件系统进行工作.汇编语言是很多课程的基础.
汇编是人和计算机沟通的最直接方式.它描述了机器最终所要执行的指令序列.学习汇编可以:充分获得底层编程体验,深刻理解机器运行的
原理,举例来说在学习操作系统时,对很多问题都会有深刻的理解.
- 本书采用8086CPU.
- 书的特点:
  1. 不讲解每一条指令的功能.
  2. 编程的平台是硬件而不是操作系统.只有直接对硬件编程,才能体会到操作系统的作用.
  3. 着重讲解重要的指令和关键概念.jmp 条件转移指令 call int
 ### 基础知识
 - 汇编语言是直接在硬件之上工作的语言,微机原理与接口(关于PC及CPU物理结构和编程结构的研究),计算机组成
 (对计算机一般的结构功能,性能的研究).汇编课程是研究如何利用硬件系统和编程结构和指令集有效灵活地控制系统
 进行工作.
 #### 1.1 机器语言
 - 机器语言是机器指令的集合.机器指令展开来讲就是一台机器可以正确执行的.机器指令是一列二进制数字,计算机
 将之转成高低电平,以使计算机的电子器件受到驱动,进行运算.
 - 早期计算机指的是可以执行机器指令,运行运算的机器.现在由PC中的一个芯片(CPU)完成,CPU是一种微处理器.我们
 提到的计算机由CPU和其它受CPU直接或间接控制的芯片,器件,设备组成的计算机系统.
 - 每一种微机处理器,由于硬件设计和内部结构不同,需要用不同的电平脉冲来控制.每一种微处理器都有自己的机器指令,
即机器语言.
- 早期程序员写0,1数字编成的程序代码打在纸带上或卡片上,再将程序通过纸带机或者卡片机输入计算机,进行运算.
用8086CPU完成运算s=768+12288-1280机器码如下.
![](image/机器码.png)
这样的机器码非常的难记和排查错误.
#### 1.2 汇编语言的产生
- 由于机器语言的问题,产生了汇编语言,汇编语言和机器语言的差别在于指令的表示上.汇编
指令是机器指令便于记忆书写的格式.
- 此后,程序员写的是汇编,可是机算机只能读懂机器指令.需要有一个将汇编指令转成
机器指令的翻译程序,这个就是编译器.
- 汇编指令-编译器->机器码 ->计算机
#### 1.3 汇编语言的组成
1. 汇编指令,机器码的助记符,有对应的机器码.
2. 伪指令,没有对应的机器码,由编译器执行,计算机并不执行.
3. 其他符号:如+ - * /,由编译器识别,没有对应的机器码.???
#### 1.4 存储器
- CPU运行的指令和数据放在存储器中,就是内存.要灵活的利用汇编语言,
要了解CPU是如何从内存中读取信息,以及向内存中写入信息.
#### 1.5 指令和数据
- 指令和数据都是二进制的东西.
#### 1.6 存储单元
- 微型机存储器的存储单元可以存储128个字节.
#### 1.7 CPU对存储器的读写
- 存储器被分为许多个存储单元.存储单元从0开始顺序编号.编号可以看作
存储单元在存储器中的地址.
- CPU从内存中读数据,首先要指定存储单元的地址,在一台微机中,有很多种器件,
CPU在读写数据的时候,还要指明是对哪一个器件进行操作,进行那种(读写)操作.
- CPU要想进数据读写,必须和外部器件(芯片)进行3类信息的将互.
  1. 存储单元的地址(地址信息)
  2. 器件的选择(控制信息)
  3. 读或写的数据(数据信息)
- 计算机能处理和传输的信息都是信号,电信号要通过导线传送.在计算机中专门有连接CPU和其他芯片的导线,
通常总称为总线,总线从物理上来讲,就是一根根导线的集合.根据传送信息的不同,总线从逻辑上又分为3类,
即地址总线,控制总线,数据总线.
![](image/CPU读取数据的过程.png)
  1.CPU通过地址总线将地址信息3发出.
  2.CPU通过控制线发出内存的读命令,选中存储器芯片,并通知它,将要从中读取数据.
  3.存储器3号单元中的数据通过数据总线送入CPU.
- 如何让一个计算机或微机处理器工作? 要让一个计算机或微处理器工作,应向它输入能够驱动它进行
工作的电平信息(机器码)
 #### 1.8 地址总线
 - CPU是通过地址总线来指定存储器存地址的.地址总线上能传送多少个不同的信息,CPU就可以对多少个
 存储单元进行寻址.
 - 一个CPU有N根地址线,则可以说这个CPU的地址总线的宽度为N.这样CPU寻多可以寻2^N次方个内存单元.
 #### 1.9 数据总线
 - CPU与内存或其他器件之间的数据传送是通过数据总线来进行的.数据总线的宽度决定了CPU和外界数据传递的速度.
一次不够可以分多次传递.
#### 1.10 控制总线
- CPU对外部器件的控制是通过控制总线来进行的.控制总线的宽度决定了CPU对外部器件的控制力.
- 每个CPU芯都有许多管脚,这些管脚和总线相连.一个CPU可以引出三种总线的宽度标志了这个CPU不
同方面的性能.
#### 1.11 内存空间地址
- 一个CPU的地址线宽度为10,那么可以寻址1024个内存单元,这1024个可寻到的内存单元就构成这个CPU
的内存地址空间.
#### 1.12 主板
- 在每台PC机中,都有一个主板,主板上有核心器件和一些主要器件.这些器件通过总线相连.这些器件有
CPU,存储器,外围芯片组,扩展插槽等.
#### 1.13 接口卡
- 计算机系统中,所有可用程序控制其工作的设备,必须受到CPU的控制.CPU对外部设备不能直接控制,
如显示器,音箱.直接控制这些设备进行工作的是插在扩展插槽上的接口卡.扩展插槽通过总线与CPU相连.
简单的说,就是CPU间接控制外部设备工作.
#### 1.14 各类存储器芯片
- RAM,ROM
#### 1.15 内存地址空间
- 物理上是独立的器件
  1. 都和CPU的总线相连
  2. CPU对它们进行读写的时候都通过控制线发出内存读写的命令
### 第二章 寄存器(CPU工作原理)
- 一个典型的CPU由运算器,控制器,寄存器等器件构成,
#### 2.10 CS和IP
- CS和IP是8086CPU中两个最关键的寄存器,它们指示了CPU当前要读取指令的地址,CS为代码段寄存器,
IP为指令指针寄存器.
 1. Instruction pointer register(IP,指令指针寄存器)
 2.  code segment (CS,代码段寄存器)
-  8086CPU的工作过程可以简要描述如下:
  1. 从CS:IP指向内存单元读取指令,读取的指令进入指令缓冲器.
  2. IP=IP+所读取指令的长度,从而指向下一条指令.(先加再执行,因为执行可能改变CS,IP的值)
  3. 执行指令.转到步骤1,重复这个过程
- 在8086CPU加电启动或复位后(即CPU刚开始工作时)CS和IP被设置为CS=F000H,IP=FFFFH,即
在8086CPU机刚启动时,CPU从内存FFFF0H单元中读取指令执行,FFFF0H单元中的指令是
8086PC机开机后执行的第一个指令.
- CS和IP很重要,它们的内容提供了CPU要执行指令的地址.
- 我们在第一章中讲过,在内存中,指令和数据没有任何区别,都是二进  
#### 2.11 修改CS,IP的指令
                                                                                                                                                - 在CPU中,程序员能够用指令读写的部件中有寄存器,程序员可以通过改变寄存器中的内容,
实现对CPU的控制.CPU从何处执行指令是由CS,IP中的内容决定的,程序员可以通过改变CS,IP中的
内容来控制CPU执行目标指令.
- 大部分寄存器的值,都可以用mov指令来改变,mov指令被称为传送指令.mov不能用于设置
IP,CS的值,是因为8086CPI没有提供这样的功能.8086CPU为CS,IP提供了另外的指令来改变它们的
值.能够改变CS,IP的内容的指令被称为转移指令.现在我们介绍一个最简单的可以修改CS,IP的
指令:jmp
- 如果想同时修改CS IP的内容,可用指令 jmp段地址:偏移地址 完成
- 若想仅修改IP的内容,可用指令 jmp 某一合法寄存器 完成
``` code
jmp ax // jmp 某一合法寄存器 的功能为:用寄存器中的值修改IP
       // jmp ax,在含义上类似于 mov IP,ax这样的指令.
```
#### 2.12代码段
- 在编程时,可以根据需要,将一组内存单元定义为一个段.可以将长度为N(n<=64Kb)的一组代码,存在一组连续,起始
地址为16的倍数的内存单元中.
- 如何使得代码段中的指令被执行呢?将一段内存当作代码段,仅仅是我们在编程时的一种
安排,CPU并不会由于这种安排,就自动将我们定义的代码段中的指令当作指令来执行.
- 2.9~2.12
  1. 段地址在8086CPU中的段寄存器中存放.当8086CPU要访问内存时,由段寄存器提供内存单元的段
地址.8086CPU有4个段寄存器,CS是用来存储指令的段地址.

- 实验1,查看CPU和内存,用机器指令和汇编指令编程
  1.debug:debug是dos,windows提供的实时模式程序的高度工具.使用它,可以查看CPU
  各种寄存器中的内容,内存的情况和在机器码级跟踪程序的运行.
  2.用到的debug的功能
    1. R命令查看改变CPU寄存器的内容
    2. D命令查看内存的内容
    3. E命令改写内存中的内容
    4. U    将内存中的机器指令翻译成汇编指令(如何查看写入或内存中原有的机器码对应的汇编指令,u 段地址:偏移地址
        查看从 对应物理地址的内存单元中的机器指令和它们所对应的汇编指令)
    5. T    执行一条机器指令
    6. A    以汇编指令的格式在内存中写入一条机器指令.
#### Debug
- Debug是DOS,Windows提供的8086程序调试工具.使用它,可以查看CPU各种寄存器中的内容,内存的情况
和机器码级别跟踪程序的运行.
- 我们用到的Debug功能
  1. 用Debug的R命令查看,改变CPU寄存器的内容
  2. 用Debug的D命令查看内存的内容.
### 第3章 寄存器(内存访问)
- 第2章中,我们主要从CPU如何执行指令的角度讲解了8086CPU的逻辑结构,形成物理地址的方法,
相关的寄存器以及一些指令.这一章,访问内存的角度继续学习.
#### 3.2 DS和 address
- CPU要读写内存单元的时候,必须先给出这个内存单元的地址.在8086PC中,内存地址由段地址和偏移
地址组成.8086CPU中有一个DS寄存器,通常用来存放要访问数据的段地址.比如我们要读取1000H单元的
内容:
```code
mov bx,1000H
mov ds,bx
mov al,[0]  //mov 1.可将数据送往寄存器 2.将一个寄存器的内容送入另一个寄存器 3 将内存单元
送往一个寄存器中. [..]表示内存单元,ds中的数据为内存单元的段地址 [..]中的数为内存的偏移地址.
```  
- 将数据送入寄存器可以用``MOV AX,1``,不能用这样的方式将数据直接送入段寄存器,
只能通过寄存器中转,这是8086CPU硬件设计问题.
#### 3.5 数据段
- 对于8086机,在编程时,我们可以根据需要将一组内存定义为一个段,我们可以将一组长度有N(N,=64K),
地址连续的,起始地址为16的倍数的内存单元当作专门存储数据的内存空间.
- 如何访问数据段中的数据呢? 将一段内存当作数据段,是我们在编程时的一种安排,我们可以在具体
操作的时候,用ds存放数据段的段地址,再根据需要,用相关指令访问数据段中的具体单元.
#### 3.6 栈
- 先进后出
#### 3.7 CPU提供栈机制
- 现今的CPU中都有栈的设计,8086CPU也不例外.8086CPU提供相关的指令来以栈的方式
访问内存空间,这意味着,我们在基于8086CPU编程的时候,可以将一段内存当作栈来使用.
- 8086CPU提供入栈和出栈指令.PUSH,POP,``push ax``,``pop ax``,8086CPU的入栈和
出栈操作都是以字为单位进行的.
- push ax的执行,由以下两步完成.
 1. sp=sp-2 ss:sp指向当前栈顶前面的单元,以当前栈顶前面的单元为新的栈顶
 2. 将ax中的内容送入ss:sp指向的内存单元处,ss:sp指向的内存单元处,ss:sp此时指向新栈顶.
- pop ax的执行过程和Push ax刚好相反
  1. 将SS:SP指向内存单元的数据送入AX中
  2. sp=sp+2,SS:SP指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶. 
- CPU如何知道当前要执行的指令的位置,CS,IP中存放这当前指令的段地址和偏移地址.
CPU如何知道栈顶位置?显然,也应该有相应的寄存器来存放栈顶的地址,8086CPU中,有两个
寄存器,段寄存器SS( Segment Selector Register)和寄存器SP,栈顶的段地址放在SS中,偏移
地址存放在SP中,任意时刻,SS:SP指向栈顶元素.push指令和pop指令执行时,CPU从SS和SP中得到
栈顶的地址.
#### 3.8 栈顶超界的问题
- 栈顶超界是危险的,8086CPU不保证我们对栈的操作不会超界.
#### 3.9 push,pop指令
- push和pop指令是可以在寄存器和内存(栈)之间传递数据.
```code
push 寄存器;将一个寄存器中的数据入栈.
push 段寄存器;将一个寄存器中的数据入栈.
//push和pop也可以在内存单元和内存单元之间传递数据
push 内存单元; 将一个内存字单元处的字入栈.
```
- 指令执行时,CPU要知道内存单元的地址,可以在push,pop指令中只给出内存单元偏移
地址,段地址在指令执行时,CPU从ds中取得.
### 第4章 第一个程序
- 编写一个完整的程序,用编译器编译成可执行文件(如.exe),在操作系统中运行.
#### 4.1 一个源程序从写出到执行的过程
- 描述一个汇编语言程序从写出到最终执行的简要过程
  1. 编写汇编源程序
  2. 使用汇编语言编译程序对源程序文件中的源程序进行编译,产生目标文件,再用``连接程序对目标文件进行连接``
 生成可在操作系统中直接运行的可执行文件.
  3. 执行可执行文件中的程序.
  - 可执行文件包含两部分
    1. 程序(从源程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据)\
    2. 相关的描述信息(比如,程序有多大,要占用多个内存空间等)
- 操作系统依照可执行文件中的描述信息,将可执行文件中的机器码和数据加载入内存.并进行相关的
初始化(比如设置CS:IP指向第一条要执行的指令),然后由CPU执行程序.    
- 使用汇编语言编译程序对源程序文件中
#### 4.2 源程序
```code
assume cs:codesg
codesg segment
start : mov ax,0123H
        mov bx,0456H
        ADD AX,BX
        ADD AX,AX
        MOV AX,4C00H
        INT 21H
CODESG ENDS
END

伪指令  segment ends是一对成对使用的伪指令,定义一个段,一个是开始,一个是结束,要有一个名称来标识.
一个汇编是由多个段组成的,用来存放代码,数据或当作栈空间来使用.一个源程序中所有将被计算机处理的
信息:指令 数据 栈被划分到了不同的段中.
codesg segment
codesg ends

end 是一个汇编程序的结束标记.

assume 含义是假设.它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联.
通过assume说明这种关联.用assume cs:codesg 将用作代码段的段codesg和CPU中的段寄存器cs联系起来.

```
1 伪指令
  - 在汇编语言源程序中,包含两种指令,一种是汇编指令,一种是伪指令.汇编指令是有对应机器码的指令,可以被
编译为机器指令,最终被CPU执行,而伪指令没有对应的机器指令,最终不被CPU所执行.伪指令是由编译器执行的
2 源程序中的程序
  - 用汇编语言写的源程序,包括伪指令和汇编指令,我们编程的最终目的是让计算机完成一定的任务.
我们这里说的程序就是指源程序中最终由计算机执行处理的指令或数据.
![](image/程序经过编译连接后变成机器码.png)
3 标号
  - 标号,如codesg,一个标号指代一个地址,是一个段名称,最终被编译连接处理为一个段的段地址.
4 程序的结构
  - 源程序是由段构成的,我们可以在段中放代码,数据,或将某个段当做栈空间.我们现在来一步步完成
一个小程序.
```code
// task 编程运算2^3
1 定义一个段,名称为abc
2 写入汇编指令,来实现我们的处理任务
3 指出程序在何处结束
4 将abc和cs联系起来(不是非这样做)
5 程序返回 程序先以汇编指令的形式存在源程序中,经编译,连接后转变为机器码,存在可执行文件中.
在DOS(一个单任务操作系统的基础上),P2在可执行文件中,必须有一个正在运行的程序P1,将P2从可执行文件中加载入内存,
将CPU的控制权交给p2,p2才能得以运行.p2开始运行后,P1暂停运行.当P2运行完毕后,应该将CPU的控制权交还给使它得以运行的程序P1,此后,
P1继续运行.CPU控制权的交还叫做程序返回.应该在程序的末尾添加返回的程序段.
如: mov ax,4c00H
    int 21H
    这两条指令所实现的功能就是程序返回.
abc segmnet
mov ax,2
add ax,ax
add ax,ax
abc ends
end
```

|目的|相关指令|指令性质|指令执行者|
|---|---|---|---|
|段结束||||
|程序结束||||
|程序返回||||

6 语法错误和逻辑错误
-  编译器发现的是语法错误.
#### 4.4 编译
- 编写 .asm的文件,编译,生成包含机器代码的目标文件.用微软的masm 汇编编译器,文件名为masm.exe
#### 4.5连接
- 连接的作用
  1. 当源程序很大时,可以将它分为多个源程序文件来编译,每个源程序编译成为目标文件后,再用连接程序将它们连接
  到一起,生成一个可执行文件.
  2. 程序中调用了某个库文件中的子程序,需要将这个库文件和该程序生成的目标文件连接到一起.
  3. 一个源文件编译后,得到了存有机器码的目标文件,目标文件中的有些内容还不能直接用来生成可执行文件.
 连接程序将这些内容处理为最终的可执行信息.所以,在只有一个源程序文件,不需要调用某个库的子程序的情况下,
 也必须用连接程序对目标文件进行处理,生成可执行文件.
 ```code
 masm 文件名
 link 文件名
 ```
 ### 第5章 [bx]和LOOP指令
 - [bx]和内存单元描述,[bx]和[0]有些类似.[0]表示内存单元,它的偏移地址是0
 ```code
 mov ax,[0] //将一个内存单元的内容送入ax,内存单元的长度为2字节(字),偏移地址为0,段地址在ds中
 mov a1,[0] //将一个内存单元的内容送入a1,内存单元的长度为1字节(字节单元),偏移地址为0,段地址在ds中
 //描述一个内存单元,需要两种信息 1 内存单元的地址 2内存单元的长度
 [bx] 同样也表示一个内存单元,它的偏移地址在bx中,比如下面的指令:
 mov ax,[bx] 将一个内存单元的内容送入ax,这个内存单元的长度为2个字节(字),偏移地址在bx中,段地址在ds中.
 ```
 - loop 循环,和指令的循环有关
 - ()是定义的描述性符号,表壳一个寄存器或一个内存单元中的内容.(ax)表示ax中的内容,(al)表示al中的内容.
 (20000H)表示内存单元为20000单元的内容()中的内存单元的地址为物理地址.
 #### 5.2 LOOP指令
 - Loop指令的格式是: loop标号
   1. (cx)= (cx)-1
   2. 判断cx中的值,不为零则转至标号处执行程序,如果为零则向下执行.
 ```code
 //计算2^12
 assume cs:code
 code segment
 mov ax,2
 add ax,ax
 add ax,ax
 .
 .
 .再做9次
 code ends
 end
```  
```code
 assume cs:code
 code segment
 mov ax,2
 mov cx,11
 s: add ax,ax #标号,在汇编语言中,标号代表一个地址,s,标识了一个地址.这个地址处有一个指令 add ax,ax.
    loop s  # loos s  cpu进行两步操作  1 (cx)=(cx)-1  2 判断 cx中的值,不为0转至标号s的地址,如果为0
    则执行下一条指令(下一条指令是 mov ax,4c00H)
    mov ax,4c00h
    int 21h
 code ends
 end
```
#### 5.3 在debug中跟踪用loop指令实现的循环程序
### 第6章 包含多个段的程序
- 前面的程序中,只有一个代码段.
- 在操作系统的环境中,合法地通过操作系统取得的空间都是安全的,因为操作系统不会让一个程序所用的空间和其他程序以及
系统自己的空间相冲突.在操作系统允许的情况下,程序可以取得任意容量的空间.
- 程序取得所需空间的方法有两种,1 在加载程序的时候为程序分配 ,2 在程序执行过程中向系统申请.
- 加载程序的时候为程序分配空间,我们在前面已经有所体验,比如我们的程序在加载的时候,取得了代码段中的存储空间.
- 我们若要一个程序在被加载的时候取得所需的空间,则必须要在源程序中做出说明.我们通过在源程序中定义段来进行内存
空间的获取.
#### 6.1 在代码段中使用数据
- 前面的课程中,是累加某些内存单元中的数据,不关注数据本身.如果要累加给定数值的数据.可以将它们一个个加载到
ax寄存器中,如果希望可以用循环的方法进得累加,在累加前,要将这些数据存储在一组地址连续的内存单元中,可以用指令一个个
将它们送入地址连续的存储单元中.
- 从规范的角度来讲,我们不能自己随便决定哪段空间可以使用.应该让系统来为我们分配.我们可以在程序中,定义我们希望
处理的数据,这些数据就会被编译,连接程序作为程序的一部分写到可执行文件中.当可执行文件中的程序被加载到内存时,
这些数据也同时被加载入内存中.与此同时,我们要处理的处理也就自然而然的获取了存储空间.
```code
assume cs:code
code segment
    //dw(define work) 定义字型数据,使用dw定义了8个字型数据.(数据之间以逗号分隔),它们所占的内存空间为16个字节.
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0987h 
    mov bx,0  //偏移地址设为0
    mov ax,0  //累加器设为0
    mov cx,8  //累加次数设为8
    s:add ax,cs:[bx]
      add bx,2
      loop s
      
      mov ax,4c00h
      int 21h
code ends
end
 用u查看指令.没有看到程序中的指令.其实看到的也是程序中的内容,只不过不是源程序中的汇编指令所对应的机器码.
 而是源程序中,在汇编指令前,用dw定义的数据.实际上,在程序中,有一个段码段,在代码段中,前面的16个字节是用dw定义 
 的数据,从第16个字节才是汇编指令的对应的机器码.
 - 如何执行程序中的指令? 用debug加载后,可以将IP设置为10h,从而使CS:IP指向程序中的第一条指令.然后再用t,p,g命令执行
 可是这样一来,就必须用Debug来执行程序.上面的例子编译,连接成可执行文件后,在系统中直接运行可能会出现问题,
 因为程序的入口不是我们所希望执行的指令.如何让这个程序在编译,连接后可以在系统中直接运行呢?我们可以在源程序中
 指明程序的入口所在.
 assume cs:code
 code segment
     //dw(define work) 定义字型数据,使用dw定义了8个字型数据.(数据之间以逗号分隔),它们所占的内存空间为16个字节.
     dw 0123h,0456h,0789h,0abch,0defh,0fedh,0987h 
     start:mov bx,0  //偏移地址设为0
           mov ax,0  //累加器设为0
           mov cx,8  //累加次数设为8
         s:add ax,cs:[bx]
           add bx,2
           loop s
       
         mov ax,4c00h
         int 21h
    code ends
 end start
 注意,在程序中加入的新内容,在程序的第一条指令的前面加上了一个标号start,而这个标号的伪指令在end的后面出现.
 end除了通知编译器程序结束处,还可以通知编译器程序的入口在什么地方.在上面的例子中,我们用end指令说明了程序的
 入口在start处,也就是说 mov bx,0 是程序的第一条指令
```
- 在前面的课程中,我们已经知道在单任务系统中,可执行文件中的程序执行过程如下.
  1. 由其他的程序(Debug,command或其他程序)将可执行文件中的程序加载入内存.
  2. 设置CS:IP指向程序的第一条要执行的指令(即程序的入口),从而使程序得以运行;
  3. 程序运行结束,返回到加载者
  根据什么设置CPU的CS:IP指向程序的第一条要执行的指令?这一点,是由可执行文件中的描述信息指明的.我们知道可
  执行文件由描述信息和程序组成,程序来源于源程序中的汇编指令和定义数据.描述信息则主要是编译,连接程序对源程序
  中相关伪指令进行处理得到的信息.我们在上面的程序中,用伪指令end描述了程序的结束和程序的入口.在编译,连接后
  由end start指明的程序入口,被转化为一个入口地址,存储在可执行文件的描述信息中.当程序被加载入内存后,加载者
  从程序的可执行文件的描述信息中读到程序的入口地址,设置CS:IP,这样CPU就从我们希望的地址处开始执行.
- 我们若要CPU从何处开始执行程序,只要在源程序中用 end标号 指明就可以了.
####  6.2 的代码段中使用栈(SS:SP 指向栈顶元素)
- 利用栈,将程序中定义的数据逆序存放.
- 程序运行时,定义的数据存放在cs:0~cs:F单元中,共8个字单元.依次将这8个字单元中的数据入栈,然后再依次出栈到8个
字单元中,从而实现数据的逆序存放.
- 要一段可以当作栈的内存空间,段空间应该由系统来分配,我们可以在程序中通过定义数据来取得一段空间,然后将这段
空间当作栈空间来用.
```code
assume cs:codesg
codesg segment
   dw 0123h,0456h.........
   dw 0,0,0  #用dw定义16个字型数据,在程序加载后,将取得16个字的内存空间.
   start : mov ax,cs
           mov ss,ax
           mov sp,30h #将设置栈顶ss:sp指向cs:30
           
           mov bx,0
           mov cx,8
         s:push cs:[bx]
           add bx,2
           loop s #以上代码将0~15单元中的8个字型数据依次入栈
           
           mov bx,0
           mov cx,8
        s0:pop cs:[bx]
           add bx,2
           loop  s0  #以上依次出栈8
           
           mov ax,4c00h
           int 21h   
        codesg ends
        end start  #指明程序的入口在start处
        我们要将cs:10~cs:2F的空间当作栈来用,初始状态下栈为空,所以ss:sp要指向栈底.则设置ss:sp指向cs:30         
```
- 在代码段中定义了16个字型数据,它们的数值都是0.这16个字型数据的值是多少,对程序来说是没有意义的,我们用dw定义16个数据,
即在程序中写入了16个字型数据.在程序在加载后,用32个字节的内存来存放它们.空间是我们要的,程序把它当作栈空间.我们的最终
目的是通过它们取得一定容量的内存空间.所以我们在描述dw的作用的时,可以说用它定义数据,也可以说用它开辟内存空间.
#### 6.3 将数据,代码,栈放入不同的段
- 在前面的内容中,我们将程序中用到的数据,栈和代码都放到了一个段里面.
  1. 这样显得程序混乱
  2. 前面程序中处理的数据很少,用到的栈空间也小,加上没有多长的代码,放到一个段里面没有问题.如果数据,栈和代码需要的空间
超过64KB,就不能放在一个段中.(一个段的容量不能大于64KB,这是8086模式的限制,并不是所有的处理器都这样)
- 所以,应该考虑用多个段来存放数据,代码和栈.
```code
用和定义代码段一样的方法来定义多个段,然后在这些段里面定义需要的数据,或通过定义数据来取得栈空间.
assume cs:code,ds:data,ss:stack
data segment
     dw 0123h...........
data ends
stack segment
     dw 0,.........
stack ends
code segment
start: mov ax,stack
       mov ss,ax
       mov sp,20 #设置栈顶ss:sp指向stack:20
       mov ax,data
       mov ds,ax #ds指向data段
       mov bx,0 ..ds:bx指向data段中的一个单元.
       mov cx,8
     s:push [bx]
       add bx,2
       loop s   //以上将data段中的0~15单元中的8个字型数据依次入栈
       
       mov bx,0
       mov cx,8 
    s0:pop [bx]
       add bx,2
       loop s0 #以上依次出栈8个字型的数据到data的0~15单元中.
    code ends
    end start   
              
          
```


- 程序中的指令要对这8个数进行累加,可是这8个数据在那?由于它们在代码段中,程序在运行的时候cs中存放代码段的
段地址,所以可以从cs中得到它们的段地址.偏移地址是多少呢?因为用dw定义的数据处于代码段的最开始.所以偏移地址为0,
这8个数据在代码段的偏移为1,2,4,6,8....程序运行是,它们的地址就是CS:0,CS:2.....
- 程序中用bx存放加2递增的偏移地址,用循环来进行累加.在循环开始前,设置(bx)=0,cs:bx指向第一个数据所在的子单元.
每次循环中(bx)=(bx)+2,cs:bx指向下一个数据所在的字单元.

### 第7章 更灵活的定位内存地址的方法
- 前面,我们用[0],[bx]的方法,在访问内存的指令中,定位内存单元的地址.本章我们主要通过具体的
问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法.
- 7.1 and和or指令
- 首先,介绍两条指令 and或or,因为我们下面的例子要用到
```code
1 and指令:逻辑与指令,按位进行与运算
mov a1,01100011B
and a1,00111011B
执行后: a1=0010011B,通过该指令可将操作对象的相应位设为0,其他位不变.
2 or指令:逻辑或指令,按位进行或运算
mov a1,01100011B
or  al,00111011B
执行后:a1=01111011B,通过该指令可将操作对象的相应位设为1,其他位不变
```
#### 7.3 以字符形式给出的数据
- 我们可以在汇编程序中,用 ‘’的方式指明数据是以字符的形式给出的,编译器将把它们转化为相对应的
ASCII码.
#### 7.5 [bx+idata]
- 在前面用[bx]的方式来指明一个内存单元,还可以用一种更为灵活的方式来指明内存单元:[bx+idata]
### 第12章 内中断
- 任何一个通用的CPU,比如8086,都具备一种能力,可以在执行完当前正在执行的指令之后,
检测到从CPU外部发送过来的或内部产生的一种特殊信息,并且可以立即对所接收到的
信息进行处理,这种特殊的信息,我们可以称其为:中断信息.中断的意思是指CPU不再接
着(刚执行完的指令)向下执行,而是转去处理这个特殊信息.
### 第15章 外中断

```code
CS:IP 指令地址
DS:[] 内存访问
SS:SP 指向栈顶元素
```