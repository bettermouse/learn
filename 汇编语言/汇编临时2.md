### 第10章 CALL和REL指令
- call和ret指令都是转移指令,它们都修改IP,或同时修改CS和IP,它们经常被共同用来实现子程序的设计.这一章讲解call和
ret指令的原理.
- 10.1 ret和retf
```code
ret指令用栈中的数据,修改IP的内容,从而实现近转移.
retf指令用栈中的数据,修改CS和IP的内容,从而实现远转移.
CPU执行ret指令时,进行下面两步
1. (IP)=((SS)*16+SP)
2.(SP)=(SP)+2
CPU执行reft指令时,进行下面4步操作:
1.(IP)=((SS)*16+(SP))
2.(SP)=(SP)+2
3.(CS)=((SS)*16+(SP))
4.(SP)=(SP)+2
可以看出,如果我们用汇编语法来解释ret和retf指令,则:
CPU执行ret指令时,相当于
pop ip
CPU执行retf指令时,相当于
pop ip
pop cs
下面的程序,ret指令执行后,(IP)=0,CS:IP指向代码的第一条指令
assume cs:code
stack segment
    db 16 dup(0)
stack ends
code segment
    mov ax,4c00h
    int 21h
start: mov ax,stack
       mov ss,ax
       mov sp,16
       mov ax,0
       push ax
       mov bx,0
       ret
code ends
end start   

下面的程序,retf指令执行后,(IP)=0,CS:IP指向代码的第一条指令  
assume cs:code
stack segment
    db 16 dup(0)
stack ends     
start: mov ax,stack
       mov ss,ax
       mov sp,16
       mov ax,0
       push cs
       push ax
       mov bx,0
       retf
code ends
end start  
```
#### 10.2 call指令
- CPU执行call指令时,进行两步操作:
  1. 将当前的IP或CS和IP压入栈中
  2. 转移
  